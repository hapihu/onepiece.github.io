<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/onepiece.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/onepiece.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/onepiece.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/onepiece.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/onepiece.github.io/css/main.css">


<link rel="stylesheet" href="/onepiece.github.io/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/onepiece.github.io/lib/pace/pace-theme-minimal.min.css">
  <script src="/onepiece.github.io/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hapihu.github.io","root":"/onepiece.github.io/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"buttons","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="排序算法学习、收纳">
<meta property="og:type" content="article">
<meta property="og:title" content="排序算法">
<meta property="og:url" content="https://hapihu.github.io/2021/01/01/sort_algorithm.assets/index.html">
<meta property="og:site_name" content="哈皮虎">
<meta property="og:description" content="排序算法学习、收纳">
<meta property="og:locale">
<meta property="og:image" content="https://hapihu.github.io/Users/hapihu/Documents/Gitee/ggsd-ddu-summary/Algorithm/sort_algorithm.assets/timsort-algorythm-1st-screenshot-3284074.png">
<meta property="og:image" content="https://hapihu.github.io/Users/hapihu/Documents/Gitee/ggsd-ddu-summary/Algorithm/sort_algorithm.assets/sort.png">
<meta property="og:image" content="https://hapihu.github.io/onepiece.github.io/2021/01/01/sort_algorithm.assets/countingSort.gif">
<meta property="article:published_time" content="2020-12-31T16:00:00.000Z">
<meta property="article:modified_time" content="2021-02-19T06:15:45.557Z">
<meta property="article:author" content="hapihu">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="排序">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hapihu.github.io/Users/hapihu/Documents/Gitee/ggsd-ddu-summary/Algorithm/sort_algorithm.assets/timsort-algorythm-1st-screenshot-3284074.png">

<link rel="canonical" href="https://hapihu.github.io/2021/01/01/sort_algorithm.assets/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>排序算法 | 哈皮虎</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>


<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/onepiece.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">哈皮虎</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/onepiece.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/onepiece.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/onepiece.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/onepiece.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/onepiece.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://hapihu.github.io/2021/01/01/sort_algorithm.assets/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/onepiece.github.io/images/avatar.gif">
      <meta itemprop="name" content="hapihu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="哈皮虎">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          排序算法
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="2021-01-01T00:00:00+08:00">2021-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-02-19 14:15:45" itemprop="dateModified" datetime="2021-02-19T14:15:45+08:00">2021-02-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/onepiece.github.io/categories/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/" itemprop="url" rel="index"><span itemprop="name">算法_排序</span></a>
                </span>
            </span>

          
            <div class="post-description">排序算法学习、收纳</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <a id="more"></a>

<p>[TOC]</p>
<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><pre class="mermaid">graph LR;
    排序算法-->选择排序
    选择排序-->简单选择排序
    选择排序-->二元选择排序
    选择排序-->堆排序
    排序算法-->插入排序
    插入排序-->直接插入排序
    插入排序-->希尔排序
    插入排序-->二分插入排序
    排序算法-->冒泡排序
    排序算法-->快速排序
    排序算法-->归并排序
    排序算法-->基数排序
    基数排序-->计数排序
    基数排序-->桶排序
    基数排序-->Radix-sort</pre>

<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p><img src="/onepiece.github.io/2021/01/01/sort_algorithm.assets/../../../../../../../../../Users/hapihu/Documents/Gitee/ggsd-ddu-summary/Algorithm/sort_algorithm.assets/timsort-algorythm-1st-screenshot-3284074.png" alt="Timsort Sorting Algorithm - Infopulse - 624512"></p>
<h2 id="对比-1"><a href="#对比-1" class="headerlink" title="对比"></a>对比</h2><ul>
<li>排序算法可以分为内部排序和外部排序<ul>
<li>内部排序是数据记录在内存中进行排序</li>
<li>而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。</li>
</ul>
</li>
<li>常见的内部排序算法有：<strong>插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序</strong>等。用一张图概括：</li>
</ul>
<p><img src="/onepiece.github.io/2021/01/01/sort_algorithm.assets/../../../../../../../../../Users/hapihu/Documents/Gitee/ggsd-ddu-summary/Algorithm/sort_algorithm.assets/sort.png" alt="十大经典排序算法 概览截图"></p>
<p><strong>关于时间复杂度</strong>：</p>
<ol>
<li>平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。</li>
<li>线性对数阶 (O(nlog2n)) 排序 快速排序、堆排序和归并排序；</li>
<li>O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。 希尔排序</li>
<li>线性阶 (O(n)) 排序 基数排序，此外还有桶、箱排序。</li>
</ol>
<p><strong>关于稳定性</strong>：</p>
<p>稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。</p>
<p>不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。</p>
<p><strong>名词解释</strong>：</p>
<p><strong>n</strong>：数据规模</p>
<p><strong>k</strong>：“桶”的个数</p>
<p><strong>In-place</strong>：占用常数内存，不占用额外内存</p>
<p><strong>Out-place</strong>：占用额外内存</p>
<p><strong>稳定性</strong>：排序后 2 个相等键值的顺序和排序之前它们的顺序相同</p>
<h1 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul>
<li>简单选择排序是最简单直观的一种算法，基本思想为每一趟从待排序的数据元素中选择最小（或最大）的一个元素作为首元素，直到所有元素排完为止，简单选择排序是不稳定排序。</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul>
<li>找出最小元素，放在左面；</li>
<li>复杂度<ul>
<li>比较次数</li>
<li>交换次数</li>
</ul>
</li>
<li>简单选择排序通过上面优化之后，无论数组原始排列如何，比较次数是不变的；</li>
<li>对于交换操作，在最好情况下也就是数组完全有序的时候，无需任何交换移动；</li>
<li>在最差情况下，也就是数组倒序的时候，交换次数为n-1次。综合下来，时间复杂度为O(n2)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 简单选择排序</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        每一趟循环比较时，min用于存放较小元素的数组下标，</span></span><br><span class="line"><span class="comment">        这样当前批次比较完毕最终存放的就是此趟内最小的元素的下标，避免每次遇到较小元素都要进行交换。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">          <span class="keyword">int</span> min = i;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">              <span class="keyword">if</span> (arr[j] &lt; arr[min]) &#123;</span><br><span class="line">                  min = j;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//进行交换，如果min发生变化，则进行交换</span></span><br><span class="line">          <span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">              swap(arr, min, i);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 交换数组元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> b</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">      arr[a] = arr[a] + arr[b];</span><br><span class="line">      arr[b] = arr[a] - arr[b];</span><br><span class="line">      arr[a] = arr[a] - arr[b];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h1 id="二元选择排序"><a href="#二元选择排序" class="headerlink" title="二元选择排序"></a>二元选择排序</h1><h2 id="实现-h"><a href="#实现-h" class="headerlink" title="实现[h]"></a>实现[h]</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length / <span class="number">2</span> ; i++) &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      每一趟循环比较时，min用于存放较小元素的数组下标，</span></span><br><span class="line"><span class="comment">      这样当前批次比较完毕最终存放的就是此趟内最小的元素的下标，避免每次遇到较小元素都要进行交换。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">      	<span class="keyword">int</span> max = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[min]) &#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[j] &gt; arr[max])&#123;</span><br><span class="line">              	max = j;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行交换，如果min发生变化，则进行交换</span></span><br><span class="line">        <span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">            swap(arr, min, i);</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="keyword">if</span>(max != arr.length - <span class="number">1</span> - i)&#123;</span><br><span class="line">          	swap(arr, max, arr.length - <span class="number">1</span> - i)</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><ul>
<li>冒泡排序的基本思想是，对相邻的元素进行两两比较，顺序相反则进行交换；</li>
<li>每一趟会将最小或最大的元素“浮”到顶端，最终达到完全有序。</li>
</ul>
<h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><ul>
<li>根据上面这种冒泡实现，若原数组本身就是有序的（这是最好情况），仅需n-1次比较就可完成；</li>
<li>若是倒序，比较次数为 n-1+n-2+…+1=n(n-1)/2，交换次数和比较次数等值。</li>
<li>所以，其时间复杂度依然为O(n^2）。综合来看，冒泡排序性能还还是选择排序的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 冒泡排序</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已然完成。</span></span><br><span class="line">          <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            	<span class="comment">//把最大的 交换到 数组最后面</span></span><br><span class="line">              <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                  swap(arr,j,j+<span class="number">1</span>);</span><br><span class="line">                  flag = <span class="keyword">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h1 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h1><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><ul>
<li>直接插入排序基本思想是每一步将一个待排序的记录，插入到前面已经排好序的有序序列中去，直到插完所有元素为止。</li>
</ul>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>简单插入排序在最好情况下，需要比较n-1次，无需交换元素，时间复杂度为O(n);</li>
<li>在最坏情况下，时间复杂度依然为O(n^2)。</li>
<li>但是在数组元素随机排列的情况下，插入排序还是要优于选择排序和冒泡排序。</li>
</ul>
<h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><ul>
<li>升序</li>
<li>后面的元素，倒序开始，依次和前面的元素比较，进行替换。</li>
<li>假设前面的元素都已经排好序了</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 插入排序</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">          <span class="keyword">int</span> j = i;</span><br><span class="line">          <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">              swap(arr, j, j-<span class="number">1</span>);</span><br><span class="line">              j--;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现-h-1"><a href="#实现-h-1" class="headerlink" title="实现[h]"></a>实现[h]</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">      <span class="keyword">int</span> k = i;</span><br><span class="line">      <span class="keyword">while</span>( K &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[k] &lt; arr[k - <span class="number">1</span>])&#123;</span><br><span class="line">          swap(arr, k , k-<span class="number">1</span>);</span><br><span class="line">          k--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li><strong>希尔排序(Shell Sort)**是插入排序的一种算法，是对直接插入排序的一个优化，也称</strong>缩小增量排序**。</li>
<li>希尔排序是非稳定排序算法。</li>
<li>希尔排序因<code>DL．Shell</code>于1959年提出而得名。</li>
</ul>
<ul>
<li>针对插入排序的改进<ul>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率。</li>
<li>插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。</li>
</ul>
</li>
</ul>
<h2 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h2><ul>
<li>1、希尔排序是将待排序的数组元素 按下标的一定增量分组 ，分成多个子序列；</li>
<li>2、然后对各个子序列进行直接插入排序算法排序；</li>
<li>3、然后依次缩减增量再进行排序，直到增量为1时，进行最后一次直接插入排序，排序结束。</li>
</ul>
<ul>
<li>增量的选择:<ul>
<li> 第一个增量=数组的长度/2,</li>
<li> 第二个增量= 第一个增量/2,</li>
<li> 第三个增量=第二个增量/2,</li>
<li> 以此类推，最后一个增量=1。</li>
</ul>
</li>
</ul>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">增量d 的范围： 1&lt;= d &lt; 待排序数组的长度  （d 需为 int 值）</span><br><span class="line">增量的取值： 一般的初次取序列（数组）的一半为增量，以后每次减半，直到增量为1。</span><br></pre></td></tr></table></figure>

<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul>
<li><p>**希尔排序的执行时间依赖于增量序列。    **</p>
<ul>
<li> 希尔排序耗时的操作有：比较 + 后移赋值。</li>
</ul>
</li>
<li><p><strong>时间复杂度情况如下：</strong>（n指待排序序列长度）</p>
<ul>
<li><strong>1) 最好情况：</strong>序列是正序排列，在这种情况下，需要进行的比较操作需（n-1）次。后移赋值操作为0次。即O(n)</li>
<li><strong>2) 最坏情况：</strong>O(nlog2n)。</li>
<li><strong>3) 渐进时间复杂度（平均时间复杂度）：</strong>O(nlog2n)</li>
</ul>
</li>
</ul>
<p>希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小，插入排序对于有序的序列效率很高。</p>
<p>所以，<strong>希尔排序的时间复杂度会比O(n²)好一些。</strong></p>
<p>希尔算法的性能与所选取的增量（分组长度）序列有很大关系。只对特定的待排序记录序列，可以准确地估算比较次数和移动次数。想要弄清比较次数和记录移动次数与增量选择之间的关系，并给出完整的数学分析，至今仍然是数学难题。</p>
<p>希尔算法在最坏的情况下和平均情况下执行效率相差不是很多，与此同时快速排序在最坏的情况下执行的效率会非常差。</p>
<p>希尔排序没有快速排序算法快，因此中等大小规模表现良好，对规模非常大的数据排序不是最优选择。<br> （<strong>注：</strong>专家们提倡，几乎任何排序工作在开始时都可以用希尔排序，若在实际使用中证明它不够快，再改成快速排序这样更高级的排序算法。）</p>
<p>作者：春莉姐姐<br>链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d730ae586cf3">https://www.jianshu.com/p/d730ae586cf3</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="实现-h-2"><a href="#实现-h-2" class="headerlink" title="实现[h]"></a>实现[h]</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] shellSort(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> d = arr.length/<span class="number">2</span>; d &gt;= <span class="number">1</span>; d = d/<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = d; i &lt; arr.length; i++)&#123;</span><br><span class="line">      <span class="keyword">int</span> k = i;</span><br><span class="line">      <span class="keyword">while</span>( K &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[k] &lt; arr[k - d])&#123;</span><br><span class="line">          swap(arr, k , k - d);</span><br><span class="line">          k -= d;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现[1]"></a>实现[1]</h2><ul>
<li><strong>三层for循环+if</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[]  insertionSort(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//希尔排序  升序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = arr.length / <span class="number">2</span>; d &gt; <span class="number">0</span>; d /= <span class="number">2</span>)&#123; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = d; i &lt; arr.length; i++)&#123; </span><br><span class="line">            <span class="comment">//i:代表即将插入的元素角标，作为每一组比较数据的最后一个元素角标 </span></span><br><span class="line">            <span class="comment">//j:代表与i同一组的数组元素角标</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - d; j &gt;= <span class="number">0</span>; j -= d)&#123; <span class="comment">//在此处-d 为了避免下面数组角标越界</span></span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + d]) &#123;<span class="comment">// j+d 代表即将插入的元素所在的角标</span></span><br><span class="line">                    <span class="comment">//符合条件，插入元素（交换位置）</span></span><br><span class="line">                    <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + d];</span><br><span class="line">                    arr[j + d] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sortdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> []arr =&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        <span class="keyword">int</span> []arr1 =&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        sort1(arr1);</span><br><span class="line">        System.out.println(Arrays.toString(arr1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 希尔排序 针对有序序列在插入时采用交换法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//增量gap，并逐步缩小增量</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> gap = arr.length/<span class="number">2</span>; gap&gt;<span class="number">0</span>; gap /= <span class="number">2</span>)&#123;</span><br><span class="line">           <span class="comment">//从第gap个元素，逐个对其所在组进行直接插入排序操作</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = gap ; i &lt; arr.length; i++)&#123;</span><br><span class="line">               <span class="keyword">int</span> j = i;</span><br><span class="line">               <span class="keyword">while</span>(j-gap &gt;= <span class="number">0</span> &amp;&amp; arr[j]&lt;arr[j-gap])&#123;</span><br><span class="line">                   <span class="comment">//插入排序采用交换法</span></span><br><span class="line">                   swap(arr,j,j-gap);</span><br><span class="line">                   j-=gap;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 希尔排序 针对有序序列在插入时采用移动法。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort1</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//增量gap，并逐步缩小增量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> gap=arr.length/<span class="number">2</span>;gap&gt;<span class="number">0</span>;gap/=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">//从第gap个元素，逐个对其所在组进行直接插入排序操作</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=gap;i&lt;arr.length;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> j = i;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                <span class="keyword">if</span>(arr[j]&lt;arr[j-gap])&#123;</span><br><span class="line">                    <span class="keyword">while</span>(j-gap&gt;=<span class="number">0</span> &amp;&amp; temp&lt;arr[j-gap])&#123;</span><br><span class="line">                        <span class="comment">//移动法</span></span><br><span class="line">                        arr[j] = arr[j-gap];</span><br><span class="line">                        j-=gap;</span><br><span class="line">                    &#125;</span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellsort3</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, gap;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> (gap = n / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)</span><br><span class="line">		<span class="keyword">for</span> (i = gap; i &lt; n; i++)</span><br><span class="line">			<span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; a[j] &gt; a[j + gap]; j -= gap)</span><br><span class="line">				Swap(a[j], a[j + gap]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>参考·《白话经典算法》</li>
</ul>
<h1 id="二分插入排序"><a href="#二分插入排序" class="headerlink" title="二分插入排序"></a>二分插入排序</h1><ul>
<li>折半插入排序</li>
</ul>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>二分插入排序，改进插入直接插入排序<br>在新元素插入到已序数组时，用二分法查找插入的位置</p>
<h2 id="算法复杂度分析"><a href="#算法复杂度分析" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h2><table>
<thead>
<tr>
<th>最坏</th>
<th>最好</th>
<th>稳定性</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>O(n^2)</td>
<td>O(nlog2n)</td>
<td>稳定</td>
<td>O(1)</td>
</tr>
</tbody></table>
<ul>
<li>最好情况：每次插入的位置k都是已序数组的最后的位置，则无需再执行移位赋值操作 O(n*log2n)</li>
<li>最坏情况：每次插入的位置k都是已序数组的最前的位置，则整个已序数组需要移位赋值 O(n^2)</li>
<li>二分查找时间复杂度 O(log2n)</li>
</ul>
<h2 id="Timsort-binarySort"><a href="#Timsort-binarySort" class="headerlink" title="Timsort::binarySort"></a>Timsort::binarySort</h2><ul>
<li><p>假设左面是排序好的</p>
</li>
<li><p>先实现升序排列</p>
</li>
<li><p>再用<code>Comparator&lt;? super T&gt; c</code>来替换比较的部分。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Timsort</span></span>&#123;</span><br><span class="line">		<span class="comment">/*二分插入排序*/</span></span><br><span class="line">  	<span class="comment">/*</span></span><br><span class="line"><span class="comment">  		a 数组</span></span><br><span class="line"><span class="comment">  		lo	第一个元素索引</span></span><br><span class="line"><span class="comment">  		hi	最后一个元素索引</span></span><br><span class="line"><span class="comment">  		start	，lo &lt;= start &lt;= hi，第一个未被排序的元素</span></span><br><span class="line"><span class="comment">  			</span></span><br><span class="line"><span class="comment">  			假设：[lo, start),是已经排序好的</span></span><br><span class="line"><span class="comment">  	*/</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">binarySort</span><span class="params">(T[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> start,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> lo &lt;= start &amp;&amp; start &lt;= hi;</span><br><span class="line">        <span class="keyword">if</span> (start == lo)</span><br><span class="line">            start++;</span><br><span class="line">        <span class="keyword">for</span> ( ; start &lt; hi; start++) &#123;</span><br><span class="line">            T pivot = a[start];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Set left (and right) to the index where a[start] (pivot) belongs</span></span><br><span class="line">          	<span class="comment">// lo &lt;= left &lt;= right &lt;=start</span></span><br><span class="line">            <span class="keyword">int</span> left = lo;</span><br><span class="line">            <span class="keyword">int</span> right = start;</span><br><span class="line">            <span class="keyword">assert</span> left &lt;= right;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Invariants:</span></span><br><span class="line"><span class="comment">             *   pivot &gt;= all in [lo, left).</span></span><br><span class="line"><span class="comment">             *   pivot &lt;  all in [right, start).</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">          	<span class="comment">/*</span></span><br><span class="line"><span class="comment">          		二分查找，找到插入的位置。</span></span><br><span class="line"><span class="comment">          	*/</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">              	<span class="comment">//中间的值</span></span><br><span class="line">                <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">              	<span class="comment">/**</span></span><br><span class="line"><span class="comment">              	【 小于0 时，顺序不对，需要调整】</span></span><br><span class="line"><span class="comment">              	【 大于0 时，顺序正确，不用调整】</span></span><br><span class="line"><span class="comment">              	</span></span><br><span class="line"><span class="comment">              	pivot 小于 a[mid]，等效于 c.compare(pivot, a[mid]) &lt; 0</span></span><br><span class="line"><span class="comment">              			在前半部分继续找</span></span><br><span class="line"><span class="comment">              	pivot 大于 a[mid]，等效于 c.compare(pivot, a[mid]) &gt; 0</span></span><br><span class="line"><span class="comment">              			在后半部分继续好</span></span><br><span class="line"><span class="comment">              	**/</span></span><br><span class="line">                <span class="keyword">if</span> (c.compare(pivot, a[mid]) &lt; <span class="number">0</span>)</span><br><span class="line">                    right = mid;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">assert</span> left == right;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * The invariants still hold: pivot &gt;= all in [lo, left) and</span></span><br><span class="line"><span class="comment">             * pivot &lt; all in [left, start), so pivot belongs at left.  Note</span></span><br><span class="line"><span class="comment">             * that if there are elements equal to pivot, left points to the</span></span><br><span class="line"><span class="comment">             * first slot after them -- that&#x27;s why this sort is stable.</span></span><br><span class="line"><span class="comment">             * Slide elements over to make room for pivot.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">int</span> n = start - left;  <span class="comment">// The number of elements to move</span></span><br><span class="line">            <span class="comment">// Switch is just an optimization for arraycopy in default case</span></span><br><span class="line">          	<span class="comment">//优化方案，当n小的时候，不用调用System.arraycopy方法。</span></span><br><span class="line">            <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:  a[left + <span class="number">2</span>] = a[left + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:  a[left + <span class="number">1</span>] = a[left];</span><br><span class="line">                         <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: System.arraycopy(a, left, a, left + <span class="number">1</span>, n);</span><br><span class="line">            &#125;</span><br><span class="line">            a[left] = pivot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*    public static native void arraycopy(Object src,  int  srcPos,</span></span><br><span class="line"><span class="comment">                                        Object dest, int destPos,</span></span><br><span class="line"><span class="comment">                                        int length);</span></span><br><span class="line"><span class="comment">                                        */</span></span><br></pre></td></tr></table></figure>

<h2 id="java-1"><a href="#java-1" class="headerlink" title="java[1]"></a>java[1]</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 二分插入排序，改进插入直接插入排序 </span></span><br><span class="line"><span class="comment">* 在新元素插入到已序数组时，用二分法查找插入的位置 </span></span><br><span class="line"><span class="comment">* 最好情况：每次插入的位置k都是已序数组的最后的位置，则无需再执行移位赋值操作 O(n*log2n) </span></span><br><span class="line"><span class="comment">* 最坏情况：每次插入的位置k都是已序数组的最前的位置，则整个已序数组需要移位赋值 O(n^2) </span></span><br><span class="line"><span class="comment">* 空间复杂度 O(1) </span></span><br><span class="line"><span class="comment">* 稳定性 稳定 </span></span><br><span class="line"><span class="comment">* 二分查找时间复杂度 O(log2n) </span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Wayne Zhang * <span class="doctag">@date</span> 2018/07/17 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryInsertion</span> </span>&#123;    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span><br><span class="line">    <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];        </span><br><span class="line">    <span class="comment">//random array        </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;            </span><br><span class="line">      Random rd = <span class="keyword">new</span> Random();            </span><br><span class="line">      a[i] = rd.nextInt(<span class="number">10</span>);        </span><br><span class="line">    &#125;        </span><br><span class="line">    System.out.println(<span class="string">&quot;Random Array :&quot;</span>);        </span><br><span class="line">    System.out.println(Arrays.toString(a));        </span><br><span class="line">    System.out.println();        </span><br><span class="line">    System.out.println(<span class="string">&quot;Binary Insertion Sort :&quot;</span>);        </span><br><span class="line">    <span class="comment">//插入排序        </span></span><br><span class="line">    <span class="comment">//外循环规定从第二个元素开始，将元素插入到已排好的数组中        </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;            </span><br><span class="line">      <span class="comment">//得到插入的位置            </span></span><br><span class="line">      <span class="keyword">int</span> k = findByBinary(a, i);            </span><br><span class="line">      <span class="comment">//保存a[i]            </span></span><br><span class="line">      <span class="keyword">int</span> key = a[i];            </span><br><span class="line">      <span class="comment">//元素后移            </span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= k; j--) &#123;                </span><br><span class="line">        a[j + <span class="number">1</span>] = a[j];            </span><br><span class="line">      &#125;            </span><br><span class="line">      a[k] = key;        </span><br><span class="line">    &#125;        </span><br><span class="line">    System.out.println(Arrays.toString(a));    </span><br><span class="line">  &#125;    </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  	[0, i - 1] 是已经排序好的；</span></span><br><span class="line"><span class="comment">  	将a[i],插入到a数组中，返回插入位置</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findByBinary</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i)</span> </span>&#123;        </span><br><span class="line">    <span class="keyword">int</span> highIndex = i - <span class="number">1</span>;        </span><br><span class="line">    <span class="keyword">int</span> lowIndex = <span class="number">0</span>;        </span><br><span class="line">    <span class="keyword">int</span> mid = -<span class="number">1</span>;        </span><br><span class="line">    <span class="keyword">while</span> (lowIndex &lt;= highIndex) &#123;            </span><br><span class="line">      mid = (highIndex + lowIndex) / <span class="number">2</span>;            </span><br><span class="line">      <span class="keyword">if</span> (a[i] &gt;= a[mid]) &#123;                </span><br><span class="line">        <span class="comment">//若相等，保证新元素插在旧元素后面                </span></span><br><span class="line">        lowIndex = mid + <span class="number">1</span>;            </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;                </span><br><span class="line">        highIndex = mid - <span class="number">1</span>;            </span><br><span class="line">      &#125;        </span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="keyword">return</span> lowIndex;    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="java-2"><a href="#java-2" class="headerlink" title="java[2]"></a>java[2]</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> binarySort;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> a[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp,left,right,mid;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;a.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = a[i];</span><br><span class="line">            left = <span class="number">0</span>;</span><br><span class="line">            right = i-<span class="number">1</span>;</span><br><span class="line">          	<span class="comment">//查找</span></span><br><span class="line">            <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">            &#123;</span><br><span class="line">                mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(temp &lt; a[mid])</span><br><span class="line">                &#123;</span><br><span class="line">                    right = mid-<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    left = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          	</span><br><span class="line">          	<span class="comment">//移位</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i-<span class="number">1</span>; j&gt;= left; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                a[j+<span class="number">1</span>] = a[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i!=left)</span><br><span class="line">            &#123;</span><br><span class="line">                a[left] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String agrs[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> []a = &#123;<span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>,<span class="number">13</span>,<span class="number">27</span>,<span class="number">49</span>&#125;;</span><br><span class="line">        BinarySort.sort(a);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> element :a)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(element+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="C语言-1"><a href="#C语言-1" class="headerlink" title="C语言[1]"></a>C语言[1]</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">二分插入排序算法（升序）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binSort</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binSort</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid,left,right,temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        left = <span class="number">0</span>;<span class="comment">//初始化已拍好序的左边界为0</span></span><br><span class="line">        right = i<span class="number">-1</span>;<span class="comment">//右边界为待排序元素的前一个位置</span></span><br><span class="line">        temp = a[i];<span class="comment">//待排序元素</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (left+right)/<span class="number">2</span>;<span class="comment">//计算中间位置</span></span><br><span class="line">            <span class="keyword">if</span>(temp&lt;a[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                right = mid<span class="number">-1</span>;<span class="comment">//如果比中间位置小则缩小右边的范围为mid-1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;<span class="comment">//如果比中间位置大则扩大右边的范围为mid+1，</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>;j&gt;=left;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            a[j+<span class="number">1</span>] = a[j];<span class="comment">//将大于等于左边界值的元素全部后移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left!=i)</span><br><span class="line">        &#123;</span><br><span class="line">            a[left] = temp;<span class="comment">//待插入元素插入位置不等于现在所处位置时，则插入空处</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[]=&#123;<span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>,<span class="number">13</span>,<span class="number">27</span>,<span class="number">49</span>&#125;;<span class="comment">//待排序数组</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(a)/(<span class="keyword">sizeof</span>(a[<span class="number">0</span>]));</span><br><span class="line">    binSort(a,len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C语言-2"><a href="#C语言-2" class="headerlink" title="C语言[2]"></a>C语言[2]</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n ,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d:&quot;</span>,i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">8</span>; j++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BInsertSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,low = <span class="number">0</span>,high = <span class="number">0</span>,mid;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;size; i++) &#123;</span><br><span class="line">        low=<span class="number">0</span>;</span><br><span class="line">        high=i<span class="number">-1</span>;</span><br><span class="line">        temp=a[i];</span><br><span class="line">        <span class="comment">//采用折半查找法判断插入位置，最终变量 low 表示插入位置</span></span><br><span class="line">        <span class="keyword">while</span> (low&lt;=high) &#123;</span><br><span class="line">            mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[mid]&gt;temp) &#123;</span><br><span class="line">                high=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有序表中插入位置后的元素统一后移</span></span><br><span class="line">        <span class="keyword">for</span> (j=i; j&gt;low; j--) &#123;</span><br><span class="line">            a[j]=a[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        a[low]=temp;<span class="comment">//插入元素</span></span><br><span class="line">        print(a, <span class="number">8</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">8</span>] = &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    BInsertSort(a, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li><p>快速排序是由东尼·霍尔所发展的一种排序算法。</p>
</li>
<li><p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p>
</li>
<li><p>快速排序又是一种分而治之思想在排序算法上的典型应用。</p>
</li>
<li><p>本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</p>
</li>
</ul>
<h2 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h2><ol>
<li>从数列中挑出一个元素，称为 “基准”（pivot）;</li>
<li><strong>这个称为分区（partition）操作</strong>:重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li>
</ol>
<p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。</p>
<p>虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p>
<h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><ul>
<li>在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。</li>
<li>在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。</li>
<li>事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</li>
<li>它是处理大数据最快的排序算法之一了。</li>
</ul>
<ul>
<li>《算法艺术与信息学竞赛》</li>
</ul>
<blockquote>
<p>快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。</p>
<p>但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。</p>
<p>所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</p>
</blockquote>
<h2 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h2><h3 id="实现-1-1"><a href="#实现-1-1" class="headerlink" title="实现[1]"></a>实现[1]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> <span class="keyword">implements</span> <span class="title">IArraySort</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] sourceArray) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 对 arr 进行拷贝，不改变参数内容</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">        <span class="keyword">return</span> quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] quickSort(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> partitionIndex = partition(arr, left, right);</span><br><span class="line">            quickSort(arr, left, partitionIndex - <span class="number">1</span>);</span><br><span class="line">            quickSort(arr, partitionIndex + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设定基准值（pivot）</span></span><br><span class="line">        <span class="keyword">int</span> pivot = left;</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">//待替换的位置索引，记录第一个大于arr[pivot]的元素位置</span></span><br><span class="line">        <span class="keyword">int</span> index = pivot + <span class="number">1</span>;	</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt;= right; i++) &#123;</span><br><span class="line">          	<span class="comment">// 只要比基准值小，就放到前面来</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">              	</span><br><span class="line">                swap(arr, i, index);</span><br><span class="line">                index++;</span><br><span class="line">              	</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      	</span><br><span class="line">      	<span class="comment">// 从 [pivot + 1, index - 1]的数据，都比arr[pivot]小</span></span><br><span class="line">        <span class="comment">// 所以，要将arr[pivot] 放到最右边</span></span><br><span class="line">        swap(arr, pivot, index - <span class="number">1</span>);</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// [pivot , index - 1] 的数据 都是小于 arr[index - 1]</span></span><br><span class="line">        <span class="keyword">return</span> index - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="DualPivotQuicksort-sort"><a href="#DualPivotQuicksort-sort" class="headerlink" title="DualPivotQuicksort::sort"></a>DualPivotQuicksort::sort</h3><ul>
<li>dual    二元</li>
<li>pivot 中心点</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DualPivotQuicksort</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QUICKSORT_THRESHOLD = <span class="number">286</span>;</span><br><span class="line">  </span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">int</span>[] work, <span class="keyword">int</span> workBase, <span class="keyword">int</span> workLen)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Use Quicksort on small arrays</span></span><br><span class="line">      	<span class="comment">// 数组小于286时，使用快速排序</span></span><br><span class="line">        <span class="keyword">if</span> (right - left &lt; QUICKSORT_THRESHOLD) &#123;</span><br><span class="line">            sort(a, left, right, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Index run[i] is the start of i-th run</span></span><br><span class="line"><span class="comment">         * (ascending or descending sequence).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span>[] run = <span class="keyword">new</span> <span class="keyword">int</span>[MAX_RUN_COUNT + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>; run[<span class="number">0</span>] = left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if the array is nearly sorted</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = left; k &lt; right; run[count] = k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[k] &lt; a[k + <span class="number">1</span>]) &#123; <span class="comment">// ascending</span></span><br><span class="line">                <span class="keyword">while</span> (++k &lt;= right &amp;&amp; a[k - <span class="number">1</span>] &lt;= a[k]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[k] &gt; a[k + <span class="number">1</span>]) &#123; <span class="comment">// descending</span></span><br><span class="line">                <span class="keyword">while</span> (++k &lt;= right &amp;&amp; a[k - <span class="number">1</span>] &gt;= a[k]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> lo = run[count] - <span class="number">1</span>, hi = k; ++lo &lt; --hi; ) &#123;</span><br><span class="line">                    <span class="keyword">int</span> t = a[lo]; a[lo] = a[hi]; a[hi] = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// equal</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> m = MAX_RUN_LENGTH; ++k &lt;= right &amp;&amp; a[k - <span class="number">1</span>] == a[k]; ) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (--m == <span class="number">0</span>) &#123;</span><br><span class="line">                        sort(a, left, right, <span class="keyword">true</span>);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * The array is not highly structured,</span></span><br><span class="line"><span class="comment">             * use Quicksort instead of merge sort.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (++count == MAX_RUN_COUNT) &#123;</span><br><span class="line">                sort(a, left, right, <span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check special cases</span></span><br><span class="line">        <span class="comment">// Implementation note: variable &quot;right&quot; is increased by 1.</span></span><br><span class="line">        <span class="keyword">if</span> (run[count] == right++) &#123; <span class="comment">// The last run contains one element</span></span><br><span class="line">            run[++count] = right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">1</span>) &#123; <span class="comment">// The array is already sorted</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Determine alternation base for merge</span></span><br><span class="line">        <span class="keyword">byte</span> odd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">1</span>; (n &lt;&lt;= <span class="number">1</span>) &lt; count; odd ^= <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use or create temporary array b for merging</span></span><br><span class="line">        <span class="keyword">int</span>[] b;                 <span class="comment">// temp array; alternates with a</span></span><br><span class="line">        <span class="keyword">int</span> ao, bo;              <span class="comment">// array offsets from &#x27;left&#x27;</span></span><br><span class="line">        <span class="keyword">int</span> blen = right - left; <span class="comment">// space needed for b</span></span><br><span class="line">        <span class="keyword">if</span> (work == <span class="keyword">null</span> || workLen &lt; blen || workBase + blen &gt; work.length) &#123;</span><br><span class="line">            work = <span class="keyword">new</span> <span class="keyword">int</span>[blen];</span><br><span class="line">            workBase = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (odd == <span class="number">0</span>) &#123;</span><br><span class="line">            System.arraycopy(a, left, work, workBase, blen);</span><br><span class="line">            b = a;</span><br><span class="line">            bo = <span class="number">0</span>;</span><br><span class="line">            a = work;</span><br><span class="line">            ao = workBase - left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            b = work;</span><br><span class="line">            ao = <span class="number">0</span>;</span><br><span class="line">            bo = workBase - left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Merging</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> last; count &gt; <span class="number">1</span>; count = last) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = (last = <span class="number">0</span>) + <span class="number">2</span>; k &lt;= count; k += <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> hi = run[k], mi = run[k - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = run[k - <span class="number">2</span>], p = i, q = mi; i &lt; hi; ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (q &gt;= hi || p &lt; mi &amp;&amp; a[p + ao] &lt;= a[q + ao]) &#123;</span><br><span class="line">                        b[i + bo] = a[p++ + ao];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        b[i + bo] = a[q++ + ao];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                run[++last] = hi;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((count &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = right, lo = run[count - <span class="number">1</span>]; --i &gt;= lo;</span><br><span class="line">                    b[i + bo] = a[i + ao]</span><br><span class="line">                );</span><br><span class="line">                run[++last] = right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span>[] t = a; a = b; b = t;</span><br><span class="line">            <span class="keyword">int</span> o = ao; ao = bo; bo = o;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="堆排序-选择排序"><a href="#堆排序-选择排序" class="headerlink" title="堆排序-选择排序"></a>堆排序-选择排序</h1><h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 大顶堆，存储左半边元素 */</span> <span class="comment">//降序</span></span><br><span class="line"><span class="keyword">private</span> PriorityQueue&lt;Integer&gt; left = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 小顶堆，存储右半边元素，并且右半边元素都大于左半边 */</span></span><br><span class="line"><span class="keyword">private</span> PriorityQueue&lt;Integer&gt; right = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br></pre></td></tr></table></figure>
<ul>
<li>堆的特性与应用<ul>
<li>用于求最大值<ul>
<li>大顶堆 ： heap.peek() </li>
</ul>
</li>
<li>用于求最小值<ul>
<li>小顶堆 ： heap.peek() </li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h2><h3 id="实现-1-2"><a href="#实现-1-2" class="headerlink" title="实现[1]"></a>实现[1]</h3><ul>
<li>数组 ==&gt; 堆<ul>
<li>1、构建大顶堆；</li>
<li>2、遍历<code>len - 1</code>次<ul>
<li>2.1、将对顶元素替换到最后面；</li>
<li>2.2、重新平衡大顶堆；<ul>
<li>2.2.1、递归平衡大顶堆</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> <span class="keyword">implements</span> <span class="title">IArraySort</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] sourceArray) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 对 arr 进行拷贝，不改变参数内容</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">        <span class="keyword">int</span> len = arr.length;</span><br><span class="line">        buildMaxHeap(arr, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">          	<span class="comment">// a[0]是当前最大值，替换到最后</span></span><br><span class="line">            swap(arr, <span class="number">0</span>, i);</span><br><span class="line">            len--;</span><br><span class="line">            heapify(arr, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">/*</span></span><br><span class="line"><span class="comment">      			从倒数第二层开始平衡</span></span><br><span class="line"><span class="comment">      	*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="keyword">int</span>) Math.floor(len / <span class="number">2</span>); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            heapify(arr, i, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">/*</span></span><br><span class="line"><span class="comment">  		 从i的孩子中，找到最大的，替换到i的位置</span></span><br><span class="line"><span class="comment">  		 假设 i-&gt;left和i-&gt;right已经完成了平衡</span></span><br><span class="line"><span class="comment">  	*/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> largest = i;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">            largest = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">            largest = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            swap(arr, i, largest);</span><br><span class="line">            heapify(arr, largest, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="基数排序-Radix-Sort"><a href="#基数排序-Radix-Sort" class="headerlink" title="基数排序-Radix-Sort"></a>基数排序-Radix-Sort</h1><ul>
<li><p>桶排序</p>
</li>
<li><p>扑克牌</p>
<ul>
<li>类似归并</li>
</ul>
</li>
</ul>
<h2 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h2><p>基数排序是一种非比较型整数排序算法，其原理是将整数按<font color="red"><strong>位数</strong></font>切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>
<p>基数排序是非比较排序算法,算法的时间复杂度是O(n). 相比于快速排序的O(nlgn),从表面上看具有不小的优势.但事实上可能有些出入,因为基数排序的n可能具有比较大的系数K.因此在具体的应用中,应首先对这个排序函数的效率进行评估.</p>
<h2 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h2><p>基数排序的主要思路是,将所有待比较数值(<strong>注意,必须是正整数</strong>)统一为同样的数位长度,数位较短的数前面补零.</p>
<p> 然后, 从最低位开始, 依次进行一次<strong>稳定排序</strong>(我们常用上一篇blog介绍的计数排序算法, 因为<strong>每个位可能的取值范围是固定的从0到9</strong>).这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列.</p>
<ul>
<li>示例数据<ul>
<li>以下描述演示了具体的排序过程(红色字体表示正在排序的数位)</li>
</ul>
</li>
</ul>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数列排序: 342 58 576 356</span><br></pre></td></tr></table></figure>



<ul>
<li>1、第一次排序(个位):</li>
</ul>
<p>3 4 <font color="red">2</font></p>
<p>5 7 <font color="red">6</font></p>
<p>3 5 <font color="red">6</font></p>
<p>0 5 <font color="red">8</font></p>
<ul>
<li>2、第二次排序(十位):</li>
</ul>
<p>3 <font color="red">4</font> 2</p>
<p>3 <font color="red">5</font> 6</p>
<p>0 <font color="red">5</font> 8</p>
<p>5 <font color="red">7</font> 6</p>
<ul>
<li>3、第三次排序(百位):</li>
</ul>
<p><font color="red">0</font> 5 8</p>
<p><font color="red">3</font> 4 2</p>
<p><font color="red">3</font> 5 6</p>
<p><font color="red">5</font> 7 6</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结果: 58 342 356 576</span><br></pre></td></tr></table></figure>



<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li><strong>问题一</strong>：为什么要从低位开始向高位排序?</li>
</ul>
<blockquote>
<p>​    **如果要从高位排序, 那么次高位的排序会影响高位已经排好的大小关系. **</p>
<p>**在数学中, 数位越高,数位值对数的大小的影响就越大.从低位开始排序,就是对这种影响的排序. **</p>
<p><strong>数位按照影响力从低到高的顺序排序, 数位影响力相同则比较数位值.</strong></p>
</blockquote>
<ul>
<li><strong>问题二</strong>：为什么同一数位的排序子程序要使用稳定排序?</li>
</ul>
<blockquote>
<p>​    <strong>稳定排序的意思是指, 待排序相同元素之间的相对前后关系,在各次排序中不会改变.比如实例中具有十位数字5的两个数字58和356, 在十位排序之前356在58之前,在十位排序之后, 356依然在58之前.</strong></p>
<p>​    <strong>稳定排序能保证,上一次的排序成果被保留,</strong></p>
<p><strong>十位数的排序过程能保留个位数的排序成果,</strong></p>
<p><strong>百位数的排序过程能保留十位数的排序成果.</strong></p>
</blockquote>
<h2 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h2><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>
<ul>
<li>基数排序：根据键值的每位数字来分配桶；</li>
<li>计数排序：每个桶只存储单一键值；</li>
<li>桶排序：每个桶存储<strong>一定范围</strong>的数值；</li>
</ul>
<h2 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h2><h3 id="实现-1-3"><a href="#实现-1-3" class="headerlink" title="实现[1]"></a>实现[1]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基数排序</span></span><br><span class="line"><span class="comment"> * 考虑负数的情况还可以参考： https://code.i-harness.com/zh-CN/q/e98fa9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> <span class="keyword">implements</span> <span class="title">IArraySort</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] sourceArray) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 对 arr 进行拷贝，不改变参数内容</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">        <span class="keyword">int</span> maxDigit = getMaxDigit(arr);</span><br><span class="line">        <span class="keyword">return</span> radixSort(arr, maxDigit);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取最高位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMaxDigit</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxValue = getMaxValue(arr);</span><br><span class="line">        <span class="keyword">return</span> getNumLenght(maxValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMaxValue</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxValue = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxValue &lt; value) &#123;</span><br><span class="line">                maxValue = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getNumLenght</span><span class="params">(<span class="keyword">long</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lenght = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> temp = num; temp != <span class="number">0</span>; temp /= <span class="number">10</span>) &#123;</span><br><span class="line">            lenght++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lenght;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] radixSort(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> maxDigit) &#123;</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> dev = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxDigit; i++, dev *= <span class="number">10</span>, mod *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="comment">// 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10)</span></span><br><span class="line">            <span class="keyword">int</span>[][] counter = <span class="keyword">new</span> <span class="keyword">int</span>[mod * <span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> bucket = ((arr[j] % mod) / dev) + mod;</span><br><span class="line">                counter[bucket] = arrayAppend(counter[bucket], arr[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> pos = <span class="number">0</span>; </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] bucket : counter) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> value : bucket) &#123;</span><br><span class="line">                    arr[pos++] = value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自动扩容，并保存数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arrayAppend(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> value) &#123;</span><br><span class="line">        arr = Arrays.copyOf(arr, arr.length + <span class="number">1</span>);</span><br><span class="line">        arr[arr.length - <span class="number">1</span>] = value;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现[2]"></a>实现[2]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] RadixSort(<span class="keyword">int</span>[] ArrayToSort, <span class="keyword">int</span> digit)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//low to high digit</span></span><br><span class="line">  	<span class="comment">//  数字位数，低位数字 到 高位数字</span></span><br><span class="line">  	<span class="comment">// digit = 3,到百位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= digit; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//temp array to store the sort result inside digit</span></span><br><span class="line">        <span class="keyword">int</span>[] tmpArray = <span class="keyword">new</span> <span class="keyword">int</span>[ArrayToSort.Length];</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//temp array for countingsort</span></span><br><span class="line">        <span class="keyword">int</span>[] tmpCountingSortArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//CountingSort</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ArrayToSort.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//split the specified digit from the element</span></span><br><span class="line">            <span class="keyword">int</span> tmpSplitDigit = ArrayToSort[i]/(<span class="keyword">int</span>)Math.Pow(<span class="number">10</span>,k-<span class="number">1</span>) - (ArrayToSort[i]/(<span class="keyword">int</span>)Math.Pow(<span class="number">10</span>,k))*<span class="number">10</span>;</span><br><span class="line">            tmpCountingSortArray[tmpSplitDigit] += <span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">1</span>; m &lt; <span class="number">10</span>; m++)</span><br><span class="line">        &#123;</span><br><span class="line">            tmpCountingSortArray[m] += tmpCountingSortArray[m - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//output the value to result</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = ArrayToSort.Length - <span class="number">1</span>; n &gt;= <span class="number">0</span>; n--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmpSplitDigit = ArrayToSort[n] / (<span class="keyword">int</span>)Math.Pow(<span class="number">10</span>,k - <span class="number">1</span>) - (ArrayToSort[n]/(<span class="keyword">int</span>)Math.Pow(<span class="number">10</span>,k)) * <span class="number">10</span>;</span><br><span class="line">          </span><br><span class="line">          	<span class="comment">//存储 tmpSplitDigit  n 的映射关系</span></span><br><span class="line">            tmpArray[tmpCountingSortArray[tmpSplitDigit]-<span class="number">1</span>] = ArrayToSort[n];</span><br><span class="line">            tmpCountingSortArray[tmpSplitDigit] -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//copy the digit-inside sort result to source array</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; ArrayToSort.Length; p++)</span><br><span class="line">        &#123;</span><br><span class="line">            ArrayToSort[p] = tmpArray[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> ArrayToSort;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现-h-3"><a href="#实现-h-3" class="headerlink" title="实现[h]"></a>实现[h]</h3><ul>
<li>基于二维数组，实现hash桶。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] radixSort(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> maxDigit) &#123;</span><br><span class="line">      <span class="keyword">int</span> mod = <span class="number">10</span>;</span><br><span class="line">      <span class="keyword">int</span> dev = <span class="number">1</span>;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">				i = 1, 	对应个位数字, int[][] counter = new int[20][0];</span></span><br><span class="line"><span class="comment">				i = 2,	对应十位数字,	int[][] counter = new int[200][0];</span></span><br><span class="line"><span class="comment">				i = 3,	对应百位数字,	int[][] counter = new int[2000][0];</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;= maxDigit; i++)&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	HashMap结构，拉链式</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mod =  (<span class="keyword">int</span>)Math.Pow(<span class="number">10</span>, i);</span><br><span class="line">    		<span class="keyword">int</span> dev =  (<span class="keyword">int</span>)Math.Pow(<span class="number">10</span>, i - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[][] counter = <span class="keyword">new</span> <span class="keyword">int</span>[mod * <span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>（<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; arr.length; k++）&#123;</span><br><span class="line">          	<span class="comment">// 求第i位的数字</span></span><br><span class="line">          	<span class="keyword">int</span> bucket = arr[k] % mod / dev + mod;</span><br><span class="line">          	</span><br><span class="line">          	counter[bucket] = arrayAppend(counter[bucket], arr[k]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] bucket : counter) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> value : bucket) &#123;</span><br><span class="line">            arr[pos++] = value;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>









<h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><h2 id="原理-7"><a href="#原理-7" class="headerlink" title="原理"></a>原理</h2><ul>
<li>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。</li>
<li>作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是<strong>有确定范围的整数</strong>。</li>
</ul>
<h2 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h2><img src="/onepiece.github.io/2021/01/01/sort_algorithm.assets/countingSort.gif" alt="动图演示" style="zoom:50%;">

<h2 id="实现-8"><a href="#实现-8" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountingSort</span> <span class="keyword">implements</span> <span class="title">IArraySort</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] sourceArray) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 对 arr 进行拷贝，不改变参数内容</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">        <span class="keyword">int</span> maxValue = getMaxValue(arr);</span><br><span class="line">        <span class="keyword">return</span> countingSort(arr, maxValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] countingSort(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> maxValue) &#123;</span><br><span class="line">        <span class="keyword">int</span> bucketLen = maxValue + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[bucketLen];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">            bucket[value]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sortedIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucketLen; j++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (bucket[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                arr[sortedIndex++] = j;</span><br><span class="line">                bucket[j]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMaxValue</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxValue = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxValue &lt; value) &#123;</span><br><span class="line">                maxValue = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><h2 id="原理-8"><a href="#原理-8" class="headerlink" title="原理"></a>原理</h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p>
<ol>
<li>在额外空间充足的情况下，尽量增大桶的数量</li>
<li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</li>
</ol>
<p>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</p>
<h2 id="实现-9"><a href="#实现-9" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BucketSort</span> <span class="keyword">implements</span> <span class="title">IArraySort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InsertSort insertSort = <span class="keyword">new</span> InsertSort();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] sourceArray) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 对 arr 进行拷贝，不改变参数内容</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">        <span class="keyword">return</span> bucketSort(arr, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] bucketSort(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> bucketSize) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> minValue = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxValue = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &lt; minValue) &#123;</span><br><span class="line">                minValue = value;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; maxValue) &#123;</span><br><span class="line">                maxValue = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      	</span><br><span class="line">        <span class="keyword">int</span> bucketCount = (<span class="keyword">int</span>) Math.floor((maxValue - minValue) / bucketSize) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[bucketCount][<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 利用映射函数将数据分配到各个桶中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = (<span class="keyword">int</span>) Math.floor((arr[i] - minValue) / bucketSize);</span><br><span class="line">            buckets[index] = arrAppend(buckets[index], arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> arrIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] bucket : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对每个桶进行排序，这里使用了插入排序</span></span><br><span class="line">            bucket = insertSort.sort(bucket);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> value : bucket) &#123;</span><br><span class="line">                arr[arrIndex++] = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自动扩容，并保存数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arrAppend(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> value) &#123;</span><br><span class="line">        arr = Arrays.copyOf(arr, arr.length + <span class="number">1</span>);</span><br><span class="line">        arr[arr.length - <span class="number">1</span>] = value;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="实现-10"><a href="#实现-10" class="headerlink" title="实现"></a>实现</h2><h3 id="实现-1-4"><a href="#实现-1-4" class="headerlink" title="实现[1]"></a>实现[1]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> <span class="keyword">implements</span> <span class="title">IArraySort</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] sourceArray) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 对 arr 进行拷贝，不改变参数内容</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">        <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> middle = (<span class="keyword">int</span>) Math.floor(arr.length / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span>[] left = Arrays.copyOfRange(arr, <span class="number">0</span>, middle);</span><br><span class="line">        <span class="keyword">int</span>[] right = Arrays.copyOfRange(arr, middle, arr.length);</span><br><span class="line">        <span class="keyword">return</span> merge(sort(left), sort(right));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span>[] merge(<span class="keyword">int</span>[] left, <span class="keyword">int</span>[] right) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[left.length + right.length];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left.length &gt; <span class="number">0</span> &amp;&amp; right.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</span><br><span class="line">                result[i++] = left[<span class="number">0</span>];</span><br><span class="line">                left = Arrays.copyOfRange(left, <span class="number">1</span>, left.length);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result[i++] = right[<span class="number">0</span>];</span><br><span class="line">                right = Arrays.copyOfRange(right, <span class="number">1</span>, right.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result[i++] = left[<span class="number">0</span>];</span><br><span class="line">            left = Arrays.copyOfRange(left, <span class="number">1</span>, left.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (right.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result[i++] = right[<span class="number">0</span>];</span><br><span class="line">            right = Arrays.copyOfRange(right, <span class="number">1</span>, right.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现-2-1"><a href="#实现-2-1" class="headerlink" title="实现[2]"></a>实现[2]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span>[] merge(<span class="keyword">int</span>[] left, <span class="keyword">int</span>[] right) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[left.length + right.length];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  			<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">  			<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  			<span class="keyword">while</span>(k &lt; left.length &amp;&amp; j &lt; right.length)&#123;</span><br><span class="line">          <span class="keyword">if</span> (left[k] &lt;= right[j]) &#123;</span><br><span class="line">            result[i] = left[k];</span><br><span class="line">            i++;</span><br><span class="line">            k++;</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            k++;</span><br><span class="line">            j++:</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="keyword">while</span>(k &lt; left.length)&#123;</span><br><span class="line">          result[i++] = left[k++];</span><br><span class="line">        &#125;</span><br><span class="line">  			</span><br><span class="line">  			<span class="keyword">while</span>(j &lt; right.length)&#123;</span><br><span class="line">          result[j++] = right[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h1 id="Timsort-sort"><a href="#Timsort-sort" class="headerlink" title="Timsort::sort"></a>Timsort::sort</h1><h2 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li><p>TimSort算法是一种起源于归并排序和插入排序的混合排序算法，设计初衷是为了在真实世界中的各种数据中可以有较好的性能。</p>
</li>
<li><p><code>TimSort</code>的本质是插入排序和归并排序的结合体。</p>
</li>
</ul>
<h2 id="原理-9"><a href="#原理-9" class="headerlink" title="原理"></a>原理</h2><ul>
<li><p>基本工作过程是：</p>
</li>
<li><p>1、扫描数组，确定其中的单调上升段和严格单调下降段，将严格下降段反转；</p>
</li>
<li><p>2、定义最小基本片段长度，短于此的单调片段通过插入排序集中为长于此的段；</p>
</li>
<li><p>3、反复归并一些相邻片段，过程中避免归并长度相差很大的片段，直至整个排序完成，所用分段选择策略可以保证**O(n log n)**时间复杂性。 </p>
</li>
</ul>
<h2 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h2><ul>
<li><p><code>TimSort</code>的本质是插入排序和归并排序的结合体，有以下特点：</p>
</li>
<li><p>1.是稳定的排序算法，最坏时间复杂度为O(N*log(N))</p>
</li>
<li><p>2.对小块进行插入排序，然后进行归并排序</p>
</li>
<li><p>总之，timsort是工业级算法，其混用<strong>插入排序</strong>与归并排序，<strong>二分搜索</strong>等算法，<strong>亮点是充分利用待排序数据可能部分有序的事实，并且依据待排序数据内容动态改变排序策略——选择性进行归并以及galloping</strong>。</p>
</li>
</ul>
<blockquote>
<p>原则上TimSort是归并排序，但小片段的合并中用了插入排序。</p>
</blockquote>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><ul>
<li><code>Timsort::sort()</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Timsort</span></span>&#123;</span><br><span class="line">  	<span class="comment">/*     </span></span><br><span class="line"><span class="comment">  	 * @param a the array to be sorted</span></span><br><span class="line"><span class="comment">     * @param lo the index of the first element, inclusive, to be sorted</span></span><br><span class="line"><span class="comment">     * @param hi the index of the last element, exclusive, to be sorted</span></span><br><span class="line"><span class="comment">     * @param c the comparator to use</span></span><br><span class="line"><span class="comment">     * @param work a workspace array (slice)</span></span><br><span class="line"><span class="comment">     * @param workBase origin of usable space in work array</span></span><br><span class="line"><span class="comment">     * @param workLen usable size of work array</span></span><br><span class="line"><span class="comment">     * @since 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">      <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, Comparator&lt;? <span class="keyword">super</span> T&gt; c,</span></span></span><br><span class="line"><span class="function"><span class="params">                         T[] work, <span class="keyword">int</span> workBase, <span class="keyword">int</span> workLen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> c != <span class="keyword">null</span> &amp;&amp; a != <span class="keyword">null</span> &amp;&amp; lo &gt;= <span class="number">0</span> &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> nRemaining  = hi - lo;</span><br><span class="line">        <span class="keyword">if</span> (nRemaining &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>;  <span class="comment">// Arrays of size 0 and 1 are always sorted</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// If array is small, do a &quot;mini-TimSort&quot; with no merges</span></span><br><span class="line">        <span class="comment">//如果数组长度小于32，调用 binarySort，也就是二分插入排序</span></span><br><span class="line">        <span class="keyword">if</span> (nRemaining &lt; MIN_MERGE) &#123;</span><br><span class="line">            <span class="keyword">int</span> initRunLen = countRunAndMakeAscending(a, lo, hi, c);</span><br><span class="line">            binarySort(a, lo, hi, lo + initRunLen, c);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * March over the array once, left to right, finding natural runs,</span></span><br><span class="line"><span class="comment">         * extending short natural runs to minRun elements, and merging runs</span></span><br><span class="line"><span class="comment">         * to maintain stack invariant.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        TimSort&lt;T&gt; ts = <span class="keyword">new</span> TimSort&lt;&gt;(a, c, work, workBase, workLen);</span><br><span class="line">        <span class="keyword">int</span> minRun = minRunLength(nRemaining);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// Identify next run</span></span><br><span class="line">            <span class="keyword">int</span> runLen = countRunAndMakeAscending(a, lo, hi, c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If run is short, extend to min(minRun, nRemaining)</span></span><br><span class="line">            <span class="keyword">if</span> (runLen &lt; minRun) &#123;</span><br><span class="line">                <span class="keyword">int</span> force = nRemaining &lt;= minRun ? nRemaining : minRun;</span><br><span class="line">                binarySort(a, lo, lo + force, lo + runLen, c);</span><br><span class="line">                runLen = force;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Push run onto pending-run stack, and maybe merge</span></span><br><span class="line">            ts.pushRun(lo, runLen);</span><br><span class="line">            ts.mergeCollapse();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Advance to find next run</span></span><br><span class="line">            lo += runLen;</span><br><span class="line">            nRemaining -= runLen;</span><br><span class="line">        &#125; <span class="keyword">while</span> (nRemaining != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Merge all remaining runs to complete sort</span></span><br><span class="line">        <span class="keyword">assert</span> lo == hi;</span><br><span class="line">        ts.mergeForceCollapse();</span><br><span class="line">        <span class="keyword">assert</span> ts.stackSize == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">		<span class="comment">/*插入排序*/</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">binarySort</span><span class="params">(T[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> start,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> lo &lt;= start &amp;&amp; start &lt;= hi;</span><br><span class="line">        <span class="keyword">if</span> (start == lo)</span><br><span class="line">            start++;</span><br><span class="line">        <span class="keyword">for</span> ( ; start &lt; hi; start++) &#123;</span><br><span class="line">            T pivot = a[start];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Set left (and right) to the index where a[start] (pivot) belongs</span></span><br><span class="line">            <span class="keyword">int</span> left = lo;</span><br><span class="line">            <span class="keyword">int</span> right = start;</span><br><span class="line">            <span class="keyword">assert</span> left &lt;= right;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Invariants:</span></span><br><span class="line"><span class="comment">             *   pivot &gt;= all in [lo, left).</span></span><br><span class="line"><span class="comment">             *   pivot &lt;  all in [right, start).</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (c.compare(pivot, a[mid]) &lt; <span class="number">0</span>)</span><br><span class="line">                    right = mid;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">assert</span> left == right;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * The invariants still hold: pivot &gt;= all in [lo, left) and</span></span><br><span class="line"><span class="comment">             * pivot &lt; all in [left, start), so pivot belongs at left.  Note</span></span><br><span class="line"><span class="comment">             * that if there are elements equal to pivot, left points to the</span></span><br><span class="line"><span class="comment">             * first slot after them -- that&#x27;s why this sort is stable.</span></span><br><span class="line"><span class="comment">             * Slide elements over to make room for pivot.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">int</span> n = start - left;  <span class="comment">// The number of elements to move</span></span><br><span class="line">            <span class="comment">// Switch is just an optimization for arraycopy in default case</span></span><br><span class="line">            <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:  a[left + <span class="number">2</span>] = a[left + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:  a[left + <span class="number">1</span>] = a[left];</span><br><span class="line">                         <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: System.arraycopy(a, left, a, left + <span class="number">1</span>, n);</span><br><span class="line">            &#125;</span><br><span class="line">            a[left] = pivot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.infopulse.com/blog/timsort-sorting-algorithm/">Timsort</a></li>
</ul>
<h1 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h1><h2 id="升序"><a href="#升序" class="headerlink" title="升序"></a>升序</h2><ul>
<li><p><code>后面的.compareTo(前面的) 返回1</code> ==&gt; 升序</p>
</li>
<li><p><font color="red">若compare 返回 -1 ，则将 a 和 b的位置换一下</font></p>
<ul>
<li>后面的比前面的大，返回1，不变；</li>
<li>后面的比前面的小，返回-1，换一个位置。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若compare 返回 1 ，则将 a 和 b的位置换一下</span></span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">				<span class="comment">//Collections::sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">								<span class="comment">// o1 是第二个参数，o2是第一个参数</span></span><br><span class="line">                <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(list);</span><br><span class="line"><span class="comment">//[1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<h2 id="降序"><a href="#降序" class="headerlink" title="降序"></a>降序</h2><ul>
<li><p><strong>后面的比前面的大，返回-1</strong></p>
</li>
<li><p><code>后面的.compareTo(前面的) 返回1</code> ==&gt; 升序</p>
</li>
<li><p>若compare 返回 -1 ，则将 o1 和 o2的位置换一下</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">     List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">	Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span>(o1 &lt; o2)&#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (o1 &gt;o2)&#123;</span><br><span class="line">                 <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     System.out.println(list);</span><br><span class="line"><span class="comment">//[3, 2, 1]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;o1 = &quot;</span> + o1 + <span class="string">&quot;, o2 = &quot;</span> + o2);</span><br><span class="line">            Integer res = o1.compareTo(o2);</span><br><span class="line">            System.out.println(<span class="string">&quot;res = &quot;</span> + res);</span><br><span class="line">            <span class="keyword">if</span>(o1 &lt; o2)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (o1 &gt;o2)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(list);</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">o1 = 2, o2 = 1	<span class="comment"># 后面的参数是o1,前面的参数是o2</span></span><br><span class="line">res = 1					</span><br><span class="line">o1 = 3, o2 = 2</span><br><span class="line">res = 1</span><br><span class="line">[3, 2, 1]</span><br></pre></td></tr></table></figure>

<h2 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h2><h3 id="compareTo函数"><a href="#compareTo函数" class="headerlink" title="compareTo函数"></a>compareTo函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Integer</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Integer anotherInteger)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> compare(<span class="keyword">this</span>.value, anotherInteger.value);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (x &lt; y) ? -<span class="number">1</span> : ((x == y) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>compareTo函数<ul>
<li>默认升序   </li>
<li>如果a小于b 返回-1； </li>
<li>如果a大于b 返回1；</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="number">1</span>;</span><br><span class="line">Integer b = <span class="number">2</span>;</span><br><span class="line">System.out.println(a.compareTo(b));</span><br><span class="line"><span class="comment">//-1</span></span><br></pre></td></tr></table></figure>

<h3 id="Collections-sort"><a href="#Collections-sort" class="headerlink" title="Collections::sort"></a>Collections::sort</h3><ul>
<li><code>Collections.sort()</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Collections</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">    list.sort(c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="List-sort"><a href="#List-sort" class="headerlink" title="List::sort"></a>List::sort</h3><ul>
<li><code>List::sort()</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  	<span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">        Object[] a = <span class="keyword">this</span>.toArray();</span><br><span class="line">        Arrays.sort(a, (Comparator) c);</span><br><span class="line">        ListIterator&lt;E&gt; i = <span class="keyword">this</span>.listIterator();</span><br><span class="line">        <span class="keyword">for</span> (Object e : a) &#123;</span><br><span class="line">            i.next();</span><br><span class="line">            i.set((E) e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Arrays-sort"><a href="#Arrays-sort" class="headerlink" title="Arrays::sort"></a>Arrays::sort</h3><ul>
<li><code>Arrays.sort()</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Arrays</span> </span>&#123;</span><br><span class="line">  		<span class="comment">// 升序</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        DualPivotQuicksort.sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">long</span>[] a)</span> </span>&#123;</span><br><span class="line">        DualPivotQuicksort.sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (LegacyMergeSort.userRequested)</span><br><span class="line">          legacyMergeSort(a);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          ComparableTimSort.sort(a, <span class="number">0</span>, a.length, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">legacyMergeSort</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">        Object[] aux = a.clone();</span><br><span class="line">        mergeSort(aux, a, <span class="number">0</span>, a.length, <span class="number">0</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] a, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">          sort(a);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (LegacyMergeSort.userRequested)</span><br><span class="line">            legacyMergeSort(a, c);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            TimSort.sort(a, <span class="number">0</span>, a.length, c, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Java-Math所有方法"><a href="#Java-Math所有方法" class="headerlink" title="Java Math所有方法"></a>Java Math所有方法</h1><p>Math类包含完成基本数学函数所需的方法。这些方法分为三类：三角函数方法、指数函数方法和服务方法。除了这些方法以外，Math类还提供了PI（π）和E（自然对数的底）可以直接使用Math.PI和Math.E来使用这两个常量。</p>
<h3 id="1-三角函数方法"><a href="#1-三角函数方法" class="headerlink" title="1. 三角函数方法"></a>1. 三角函数方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">sin</span><span class="params">(<span class="keyword">double</span> radians)</span>             <span class="comment">//正弦函数  </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">cos</span><span class="params">(<span class="keyword">double</span> radians)</span>             <span class="comment">//余弦函数  </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">tan</span><span class="params">(<span class="keyword">double</span> radians)</span>             <span class="comment">//正切函数  </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">toRadians</span><span class="params">(<span class="keyword">double</span> degree)</span>        <span class="comment">//度转换成弧度  </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">toDegree</span><span class="params">(<span class="keyword">double</span> radians)</span>        <span class="comment">//弧度转换成度  </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">asin</span><span class="params">(<span class="keyword">double</span> a)</span>                  <span class="comment">//反正弦  </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">acos</span><span class="params">(<span class="keyword">double</span> a)</span>                  <span class="comment">//反余弦  </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">atan</span><span class="params">(<span class="keyword">double</span> a)</span>                  <span class="comment">//反正切</span></span></span><br></pre></td></tr></table></figure>

<h3 id="2-指数函数方法"><a href="#2-指数函数方法" class="headerlink" title="2. 指数函数方法"></a>2. 指数函数方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">exp</span><span class="params">(<span class="keyword">double</span> x)</span>                   <span class="comment">//e^x  </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">log</span><span class="params">(<span class="keyword">double</span> x)</span>                   <span class="comment">//ln（x）  </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">log10</span><span class="params">(<span class="keyword">double</span> x)</span>                 <span class="comment">//log 10（x）  </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span>          <span class="comment">//a^b  </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> x)</span>                  <span class="comment">//√x </span></span></span><br></pre></td></tr></table></figure>

<h3 id="3-取整方法"><a href="#3-取整方法" class="headerlink" title="3. 取整方法"></a>3. 取整方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">ceil</span><span class="params">(<span class="keyword">double</span> x)</span>                 <span class="comment">// 得到不小于某数的最大整数  </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">floor</span><span class="params">(<span class="keyword">double</span> x)</span>                <span class="comment">//得到不大于某数的最小整数  </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">rint</span><span class="params">(<span class="keyword">double</span> x)</span>                 <span class="comment">//返回值为最接近参数的double值。如果这两个整数的double值都同样接近，就取偶数  </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">round</span><span class="params">(<span class="keyword">float</span> x)</span>                    <span class="comment">//返回（int）Math.floor（x+0.5）  </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">round</span><span class="params">(<span class="keyword">double</span> x)</span>                  <span class="comment">//返回（long）Math.floor（x+0.5） </span></span></span><br></pre></td></tr></table></figure>

<h3 id="4-min-max-abs-random方法"><a href="#4-min-max-abs-random方法" class="headerlink" title="4. min,max,abs,random方法"></a>4. min,max,abs,random方法</h3><p>min()返回两个数的最小值</p>
<p>max()返回两个数的最大值</p>
<p>abs()返回一个数的绝对值</p>
<p>random()可以生成大于等于0.0且小于1.0的double型随机数</p>
<h1 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h1><h2 id="Arrays-copyOf"><a href="#Arrays-copyOf" class="headerlink" title="Arrays::copyOf"></a>Arrays::copyOf</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Arrays</span> </span>&#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] copyOf(<span class="keyword">byte</span>[] original, <span class="keyword">int</span> newLength) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] copy = <span class="keyword">new</span> <span class="keyword">byte</span>[newLength];</span><br><span class="line">        System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                         Math.min(original.length, newLength));</span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/JS-Sorting-Algorithm/README.md#64ovt4">十大经典排序算法</a></li>
</ul>

    </div>

    
    
    
        <div class="reward-container">
  <div>我❤️小💰💰</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    Donate
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/onepiece.github.io/images/wechat.jpg" alt="hapihu WeChat Pay">
        <p>WeChat Pay</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/onepiece.github.io/images/alipay.jpg" alt="hapihu Alipay">
        <p>Alipay</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/onepiece.github.io/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
              <a href="/onepiece.github.io/tags/%E6%8E%92%E5%BA%8F/" rel="tag"># 排序</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/onepiece.github.io/2021/01/01/java_jvm.assets/" rel="prev" title="深入理解JVM虚拟机--学习记录">
      <i class="fa fa-chevron-left"></i> 深入理解JVM虚拟机--学习记录
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-number">1.</span> <span class="nav-text">排序算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E7%B1%BB"><span class="nav-number">1.1.</span> <span class="nav-text">分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94"><span class="nav-number">1.2.</span> <span class="nav-text">对比</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94-1"><span class="nav-number">1.3.</span> <span class="nav-text">对比</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-number">2.</span> <span class="nav-text">简单选择排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">2.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.2.</span> <span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%85%83%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-number">3.</span> <span class="nav-text">二元选择排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-h"><span class="nav-number">3.1.</span> <span class="nav-text">实现[h]</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-number">4.</span> <span class="nav-text">冒泡排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-1"><span class="nav-number">4.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">4.2.</span> <span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">5.</span> <span class="nav-text">直接插入排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-2"><span class="nav-number">5.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E7%82%B9"><span class="nav-number">5.2.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-2"><span class="nav-number">5.3.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-h-1"><span class="nav-number">5.4.</span> <span class="nav-text">实现[h]</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="nav-number">6.</span> <span class="nav-text">希尔排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-number">6.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-3"><span class="nav-number">6.2.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">6.3.</span> <span class="nav-text">时间复杂度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-h-2"><span class="nav-number">6.4.</span> <span class="nav-text">实现[h]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">6.5.</span> <span class="nav-text">实现[1]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-3"><span class="nav-number">6.6.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-4"><span class="nav-number">6.7.</span> <span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">7.</span> <span class="nav-text">二分插入排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF"><span class="nav-number">7.1.</span> <span class="nav-text">基本思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="nav-number">7.2.</span> <span class="nav-text">算法复杂度分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Timsort-binarySort"><span class="nav-number">7.3.</span> <span class="nav-text">Timsort::binarySort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java-1"><span class="nav-number">7.4.</span> <span class="nav-text">java[1]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java-2"><span class="nav-number">7.5.</span> <span class="nav-text">java[2]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C%E8%AF%AD%E8%A8%80-1"><span class="nav-number">7.6.</span> <span class="nav-text">C语言[1]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C%E8%AF%AD%E8%A8%80-2"><span class="nav-number">7.7.</span> <span class="nav-text">C语言[2]</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">8.</span> <span class="nav-text">快速排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="nav-number">8.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-4"><span class="nav-number">8.2.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-1"><span class="nav-number">8.3.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-5"><span class="nav-number">8.4.</span> <span class="nav-text">实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-1-1"><span class="nav-number">8.4.1.</span> <span class="nav-text">实现[1]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DualPivotQuicksort-sort"><span class="nav-number">8.4.2.</span> <span class="nav-text">DualPivotQuicksort::sort</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-number">9.</span> <span class="nav-text">堆排序-选择排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%A0%86"><span class="nav-number">9.1.</span> <span class="nav-text">Java堆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-6"><span class="nav-number">9.2.</span> <span class="nav-text">实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-1-2"><span class="nav-number">9.2.1.</span> <span class="nav-text">实现[1]</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F-Radix-Sort"><span class="nav-number">10.</span> <span class="nav-text">基数排序-Radix-Sort</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D-2"><span class="nav-number">10.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-5"><span class="nav-number">10.2.</span> <span class="nav-text">原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-number">10.2.1.</span> <span class="nav-text">问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-6"><span class="nav-number">10.3.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-7"><span class="nav-number">10.4.</span> <span class="nav-text">实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-1-3"><span class="nav-number">10.4.1.</span> <span class="nav-text">实现[1]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-2"><span class="nav-number">10.4.2.</span> <span class="nav-text">实现[2]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-h-3"><span class="nav-number">10.4.3.</span> <span class="nav-text">实现[h]</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="nav-number">11.</span> <span class="nav-text">计数排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-7"><span class="nav-number">11.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E7%A4%BA"><span class="nav-number">11.2.</span> <span class="nav-text">图示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-8"><span class="nav-number">11.3.</span> <span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A1%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">12.</span> <span class="nav-text">桶排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-8"><span class="nav-number">12.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-9"><span class="nav-number">12.2.</span> <span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">13.</span> <span class="nav-text">归并排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-10"><span class="nav-number">13.1.</span> <span class="nav-text">实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-1-4"><span class="nav-number">13.1.1.</span> <span class="nav-text">实现[1]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-2-1"><span class="nav-number">13.1.2.</span> <span class="nav-text">实现[2]</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Timsort-sort"><span class="nav-number">14.</span> <span class="nav-text">Timsort::sort</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D-3"><span class="nav-number">14.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-9"><span class="nav-number">14.2.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-2"><span class="nav-number">14.3.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BA%90%E7%A0%81"><span class="nav-number">14.4.</span> <span class="nav-text">源码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">14.5.</span> <span class="nav-text">参考</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Comparator"><span class="nav-number">15.</span> <span class="nav-text">Comparator</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%87%E5%BA%8F"><span class="nav-number">15.1.</span> <span class="nav-text">升序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%8D%E5%BA%8F"><span class="nav-number">15.2.</span> <span class="nav-text">降序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BA%90%E7%A0%81-1"><span class="nav-number">15.3.</span> <span class="nav-text">源码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#compareTo%E5%87%BD%E6%95%B0"><span class="nav-number">15.3.1.</span> <span class="nav-text">compareTo函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Collections-sort"><span class="nav-number">15.3.2.</span> <span class="nav-text">Collections::sort</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List-sort"><span class="nav-number">15.3.3.</span> <span class="nav-text">List::sort</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Arrays-sort"><span class="nav-number">15.3.4.</span> <span class="nav-text">Arrays::sort</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-Math%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95"><span class="nav-number">16.</span> <span class="nav-text">Java Math所有方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95"><span class="nav-number">16.0.1.</span> <span class="nav-text">1. 三角函数方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%8C%87%E6%95%B0%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95"><span class="nav-number">16.0.2.</span> <span class="nav-text">2. 指数函数方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%8F%96%E6%95%B4%E6%96%B9%E6%B3%95"><span class="nav-number">16.0.3.</span> <span class="nav-text">3. 取整方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-min-max-abs-random%E6%96%B9%E6%B3%95"><span class="nav-number">16.0.4.</span> <span class="nav-text">4. min,max,abs,random方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Arrays"><span class="nav-number">17.</span> <span class="nav-text">Arrays</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Arrays-copyOf"><span class="nav-number">17.1.</span> <span class="nav-text">Arrays::copyOf</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83-1"><span class="nav-number">18.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">hapihu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/onepiece.github.io/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/onepiece.github.io/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/onepiece.github.io/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/hapihu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hapihu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://gitee.com/happyHapihu" title="Gitee → https:&#x2F;&#x2F;gitee.com&#x2F;happyHapihu" rel="noopener" target="_blank"><i class="fab fa-gitee fa-fw"></i>Gitee</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:576816423@qq.com" title="E-Mail → mailto:576816423@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://github.com/" title="https:&#x2F;&#x2F;github.com&#x2F;" rel="noopener" target="_blank">GitHub</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://gitee.com/" title="https:&#x2F;&#x2F;gitee.com&#x2F;" rel="noopener" target="_blank">Gitee</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hapihu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='150' src="/onepiece.github.io/lib/canvas-nest/canvas-nest.min.js"></script>
  <script size="300" alpha="0.6" zIndex="-1" src="/onepiece.github.io/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/onepiece.github.io/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/onepiece.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/onepiece.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/onepiece.github.io/js/utils.js"></script>

<script src="/onepiece.github.io/js/motion.js"></script>


<script src="/onepiece.github.io/js/schemes/pisces.js"></script>


<script src="/onepiece.github.io/js/next-boot.js"></script>


  <script defer src="/onepiece.github.io/lib/three/three.min.js"></script>


  













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '59399f7d80e8a0969145',
      clientSecret: 'b335909b5cd85d458bba132d54ec3f9d5bf01d73',
      repo        : 'onepiece.github.io',
      owner       : 'hapihu',
      admin       : ['hapihu'],
      id          : 'abaec738c9e5b086e2daa5f512012416',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
